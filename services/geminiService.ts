

import { GoogleGenAI, Modality, Type } from "@google/genai";
import { 
    GARMENT_CATEGORIES, 
    StyleOption, 
    PHOTOREALISTIC_APPAREL_PROMPT,
    PHOTOREALISTIC_SCENE_PROMPT,
    TECHNICAL_SKETCH_PROMPT,
    EASY_PROMPT_PARSER,
    ADDITIONAL_VIEW_PHOTO_PROMPT,
    ADDITIONAL_VIEW_SKETCH_PROMPT,
    PHOTOREALISTIC_APPAREL_PROMPT_WITH_SEARCH,
    MockupConfig
} from '../constants';
import type { ModificationRequest } from "../components/EditorPanel";

const API_KEY = process.env.API_KEY;

if (!API_KEY) {
  throw new Error("API_KEY environment variable not set");
}

const ai = new GoogleGenAI({ apiKey: API_KEY });

export interface GroundingSource {
  uri: string;
  title: string;
}

// Helper to convert data URL to base64 string
function dataUrlToBase64(dataUrl: string): string {
  const regex = /^data:image\/(png|jpeg|gif|webp);base64,/;
  return dataUrl.replace(regex, '');
}

function cleanAndParseJson(jsonString: string): any {
  // AI can sometimes wrap the JSON in markdown-style code blocks or add conversation.
  // This extracts the JSON object from the string.
  const match = jsonString.match(/\{[\s\S]*\}/);
  if (match && match[0]) {
    try {
      return JSON.parse(match[0]);
    } catch (error) {
      console.error("Failed to parse extracted JSON string:", match[0], error);
      // Fall through to the generic error
    }
  }
  
  console.error("Could not find or parse JSON object in string:", jsonString);
  // Re-throw a more specific error to be caught by the UI handler.
  throw new Error("The AI returned an invalid data format. Please try again.");
}

export async function parseEasyPrompt(prompt: string): Promise<Partial<MockupConfig>> {
  try {
    const response = await ai.models.generateContent({
      model: "gemini-2.5-flash",
      contents: EASY_PROMPT_PARSER.replace('{{prompt}}', prompt),
      config: {
        responseMimeType: "application/json",
        responseSchema: {
          type: Type.OBJECT,
          properties: {
            selectedGarment: { type: Type.STRING },
            selectedDesignStyle: { type: Type.STRING },
            selectedColor: { type: Type.STRING },
            selectedMaterial: { type: Type.STRING },
            selectedStyle: { type: Type.STRING },
          }
        },
      },
    });

    const jsonString = response.text.trim();
    return cleanAndParseJson(jsonString) as Partial<MockupConfig>;
  } catch (error) {
    if (error instanceof Error && error.message.includes("invalid data format")) {
        throw error;
    }
    console.error("Error parsing easy prompt:", error);
    throw new Error("The AI couldn't understand that request. Please try rephrasing.");
  }
}

export async function generateMockup(
  config: MockupConfig,
  view: string
): Promise<{ imageUrl: string; groundingSources: GroundingSource[] }> {
  const garmentDescription = config.useAiApparel ? config.aiApparelPrompt : config.selectedGarment;
  const cleanDesignStyle = config.selectedDesignStyle.replace(/\[|\]/g, '');

  // --- 0. Photorealistic with Google Search ---
  if (config.useGoogleSearch && config.selectedStyle === 'Photorealistic Mockup' && !config.customMaterialTexture) {
      const finalPrompt = PHOTOREALISTIC_APPAREL_PROMPT_WITH_SEARCH
          .replace('{{garment}}', garmentDescription)
          .replace('{{color}}', config.selectedColor)
          .replace('{{material}}', config.selectedMaterial)
          .replace('{{designStyle}}', cleanDesignStyle)
          .replace('{{view}}', view);

      try {
          const response = await ai.models.generateContent({
              model: 'gemini-2.5-flash-image',
              contents: { parts: [{ text: finalPrompt }] },
              tools: [{googleSearch: {}}],
              config: { responseModalities: [Modality.IMAGE] },
          });

          const part = response.candidates?.[0]?.content?.parts?.[0];
          const groundingChunks = response.candidates?.[0]?.groundingMetadata?.groundingChunks || [];
          
          const sources: GroundingSource[] = groundingChunks
            .map(chunk => chunk.web)
            .filter((web): web is { uri: string; title: string; } => !!web)
            .map(web => ({ uri: web.uri, title: web.title || 'Untitled Source' }));

          if (part?.inlineData) {
              const imageUrl = `data:image/png;base64,${part.inlineData.data}`;
              return { imageUrl, groundingSources: sources };
          } else {
              console.error("Gemini API returned no image with search:", JSON.stringify(response, null, 2));
              throw new Error("No image was generated by the API using Google Search.");
          }

      } catch (error: any) {
          console.error("Error generating mockup with Google Search:", error);
          if (error.toString().includes('RESOURCE_EXHAUSTED') || (error.message && error.message.includes('429'))) {
              throw new Error("Request limit reached. Please wait a moment and try again.");
          }
          throw new Error("Failed to generate mockup with Google Search. Please try again.");
      }
  }


  // --- 1. Technical Sketch ---
  if (config.selectedStyle === 'Technical Sketch Style') {
    const finalPrompt = TECHNICAL_SKETCH_PROMPT
      .replace('{{garment}}', garmentDescription)
      .replace('{{designStyle}}', cleanDesignStyle)
      .replace('{{view}}', view);
    
    try {
      const response = await ai.models.generateContent({
        model: 'gemini-2.5-flash-image',
        contents: { parts: [{ text: finalPrompt }] },
        config: { responseModalities: [Modality.IMAGE] },
      });
      const part = response.candidates?.[0]?.content?.parts?.[0];
      if (part?.inlineData) {
        const imageUrl = `data:image/png;base64,${part.inlineData.data}`;
        return { imageUrl, groundingSources: [] };
      } else {
        console.error("Gemini API returned no image for sketch:", JSON.stringify(response, null, 2));
        throw new Error("No sketch was generated by the API.");
      }
    } catch (error: any) {
      console.error("Error generating technical sketch:", error);
      if (error.toString().includes('RESOURCE_EXHAUSTED') || (error.message && error.message.includes('429'))) {
          throw new Error("Request limit reached. Please wait a moment and try again.");
      }
      throw new Error("Failed to generate technical sketch. Please try again.");
    }
  }

  // --- 2. Photorealistic Mockup ---

  // --- 2a. With Custom Texture ---
  if (config.customMaterialTexture) {
    let finalPrompt: string;

    if (config.useAiModelScene) {
      finalPrompt = `
        Using the provided fabric texture image, create a high-end, photorealistic fashion photograph for an e-commerce campaign.
        - Garment: A ${garmentDescription}.
        - Model: ${config.aiModelPrompt}.
        - Scene: ${config.aiScenePrompt}.
        - View: Show the ${view} of the garment.
        - Color Overlay: The final garment should be tinted with the color ${config.selectedColor}.
        - Style: The design aesthetic is ${cleanDesignStyle}.
        - Final Image Rules: Do not add any text, logos, or watermarks. The focus should be on the apparel.
      `;
    } else {
      finalPrompt = `
        Using the provided fabric texture image, create a high-end, e-commerce style photorealistic mockup of a single garment.
        - Garment: A ${garmentDescription}.
        - View: Show the ${view} of the garment.
        - Color Overlay: The final garment should be tinted with the color ${config.selectedColor}.
        - Style: The design aesthetic is ${cleanDesignStyle}.
        - Presentation: The garment should be presented in a "ghost mannequin" or "flat lay" style.
        - Background: Use a neutral light gray studio background (#E0E0E0) with a subtle floor shadow.
        - Final Image Rules: The final image must be purely visual. It must NOT contain any text, labels, hangers, props, or human figures.
      `;
    }
    
    const textureImagePart = { 
      inlineData: { 
        mimeType: config.customMaterialTexture.substring(5, config.customMaterialTexture.indexOf(';')),
        data: dataUrlToBase64(config.customMaterialTexture) 
      } 
    };
    const textPart = { text: finalPrompt };

    try {
      const response = await ai.models.generateContent({
        model: 'gemini-2.5-flash-image',
        contents: { parts: [textureImagePart, textPart] },
        config: { responseModalities: [Modality.IMAGE] },
      });
      const part = response.candidates?.[0]?.content?.parts?.[0];
      if (part?.inlineData) {
        const imageUrl = `data:image/png;base64,${part.inlineData.data}`;
        return { imageUrl, groundingSources: [] };
      } else {
        console.error("Gemini response did not contain image data:", JSON.stringify(response, null, 2));
        throw new Error("The AI failed to generate a mockup from the custom texture.");
      }
    } catch (error: any) {
      console.error("Error generating mockup with custom texture:", error);
       if (error.toString().includes('RESOURCE_EXHAUSTED') || (error.message && error.message.includes('429'))) {
          throw new Error("Request limit reached. Please wait a moment and try again.");
      }
      throw new Error("Failed to generate mockup with custom texture. Please try again.");
    }
  } else {
    // --- 2b. Without Custom Texture (Standard) ---
    const basePrompt = config.useAiModelScene ? PHOTOREALISTIC_SCENE_PROMPT : PHOTOREALISTIC_APPAREL_PROMPT;
    const finalPrompt = basePrompt
      .replace('{{garment}}', garmentDescription)
      .replace('{{color}}', config.selectedColor)
      .replace('{{material}}', config.selectedMaterial)
      .replace('{{designStyle}}', cleanDesignStyle)
      .replace('{{view}}', view)
      .replace('{{model}}', config.aiModelPrompt)
      .replace('{{scene}}', config.aiScenePrompt);

    try {
      const response = await ai.models.generateContent({
        model: 'gemini-2.5-flash-image',
        contents: { parts: [{ text: finalPrompt }] },
        config: { responseModalities: [Modality.IMAGE] },
      });
      const part = response.candidates?.[0]?.content?.parts?.[0];
      if (part?.inlineData) {
        const imageUrl = `data:image/png;base64,${part.inlineData.data}`;
        return { imageUrl, groundingSources: [] };
      } else {
        console.error("Gemini API returned no image for mockup:", JSON.stringify(response, null, 2));
        throw new Error("No image was generated by the API.");
      }
    } catch (error: any) {
      console.error("Error generating photorealistic mockup:", error);
      if (error.toString().includes('RESOURCE_EXHAUSTED') || (error.message && error.message.includes('429'))) {
          throw new Error("Request limit reached. Please wait a moment and try again.");
      }
      throw new Error("Failed to generate mockup. The AI may be experiencing issues.");
    }
  }
}

export async function generateAdditionalView(
  baseImage: string,
  config: MockupConfig,
  view: string
): Promise<string> {
  let promptTemplate: string;
  const model = 'gemini-2.5-flash-image';

  if (config.selectedStyle === 'Technical Sketch Style') {
    promptTemplate = ADDITIONAL_VIEW_SKETCH_PROMPT;
  } else {
    promptTemplate = ADDITIONAL_VIEW_PHOTO_PROMPT;
  }
  
  const finalPrompt = promptTemplate.replace('{{view}}', view);

  const referenceImagePart = { 
    inlineData: { 
      mimeType: 'image/png',
      data: dataUrlToBase64(baseImage) 
    } 
  };
  const textPart = { text: finalPrompt };

  try {
    const response = await ai.models.generateContent({
      model: model,
      contents: { parts: [referenceImagePart, textPart] },
      config: {
        responseModalities: [Modality.IMAGE],
      },
    });

    const part = response.candidates?.[0]?.content?.parts?.[0];
    if (part?.inlineData) {
      return `data:image/png;base64,${part.inlineData.data}`;
    } else {
      console.error(`Gemini API returned no image for additional view (${view}):`, JSON.stringify(response, null, 2));
      throw new Error(`The AI failed to generate the ${view} view.`);
    }
  } catch (error: any) {
    console.error(`Error generating additional view (${view}):`, error);
    if (error.toString().includes('RESOURCE_EXHAUSTED') || (error.message && error.message.includes('429'))) {
        throw new Error("Request limit reached. Please wait a moment and try again.");
    }
    throw new Error(`Failed to generate the ${view} view. Please try again.`);
  }
}


export async function generateGraphic(
    prompt: string, 
    garment: string, 
    placement: string, 
    color: string,
    designStyle: string,
    texturePrompt?: string
): Promise<string> {

  let fullPrompt = `
  You are a graphic asset generator for apparel. Your goal is to create an isolated, professional graphic with a transparent background.

  **Primary Graphic Goal:**
  - **Prompt:** A graphic of "${prompt}".
  - **Primary Color:** ${color}
  
  **Destination Context (CRUCIAL):**
  - **Garment:** ${garment}
  - **Design Style:** ${designStyle}
  - **Intended Placement:** ${placement}

  **Generation Instructions:**
  1.  **Style Adaptation:** Interpret the graphic prompt ("${prompt}") through the lens of the Design Style (${designStyle}). DO NOT generate a generic graphic. The aesthetic must match the target style. For example, a [Japanese Streetwear] lion should look different from a [Minimalist/Normcore] lion.
  2.  **Placement Optimization:** Since the graphic is for the ${placement} area, ensure its shape and orientation are visually impactful for that location.
  `;
  
  if (texturePrompt && texturePrompt.trim() !== '') {
    fullPrompt += `
  3.  **Texture:** CRITICAL: The graphic MUST have the visual texture of "${texturePrompt}". It should not look flat. For example, if the texture prompt is "embroidered patch", the result must look like it's made of thread. If it's "leather", it should have a leather texture.
    `;
  }

  fullPrompt += `
  **CRITICAL OUTPUT RULES:**
  1.  **TRANSPARENT BACKGROUND:** The final image file **MUST** have a transparent alpha channel.
  2.  **NO BACKGROUND COLOR:** Do NOT render any background color, not even white. The background must be fully transparent.
  3.  **GRAPHIC ONLY:** Do NOT include the garment, shadows, or any other elements in the image. The output must be **only the isolated graphic**.
  `;

  try {
    const response = await ai.models.generateContent({
        model: 'gemini-2.5-flash-image',
        contents: { parts: [{ text: fullPrompt }] },
        config: { responseModalities: [Modality.IMAGE] },
    });

    const part = response.candidates?.[0]?.content?.parts?.[0];
    if (part?.inlineData) {
      return `data:image/png;base64,${part.inlineData.data}`;
    } else {
      console.error("Gemini API returned no image for graphic:", JSON.stringify(response, null, 2));
      throw new Error("No graphic was generated by the API.");
    }
  } catch (error: any) {
    console.error("Error calling Gemini API for graphic generation:", error);
    if (error.toString().includes('RESOURCE_EXHAUSTED') || (error.message && error.message.includes('429'))) {
        throw new Error("Request limit reached. Please wait a moment and try again.");
    }
    throw new Error("Failed to generate graphic. Please check the console for more details.");
  }
}

export async function generateColorPalette(
    garmentColor: string, 
    designStyle: string
): Promise<string[]> {
  const prompt = `
    You are an expert color theorist and fashion designer.
    My garment's primary color is "${garmentColor}".
    The design style is "${designStyle}".

    Create a palette of 5 colors (including neutral and accent colors) that would complement this garment and style perfectly.

    Return ONLY a JSON array of strings containing the HEX codes.
    Example: ["#FFFFFF", "#000000", "#FFD700", "#BDB76B", "#8A2BE2"]
  `;

  try {
    const response = await ai.models.generateContent({
      model: "gemini-2.5-flash",
      contents: prompt,
      config: {
        responseMimeType: "application/json",
        responseSchema: {
          type: Type.ARRAY,
          items: { type: Type.STRING },
        }
      },
    });

    const palette = JSON.parse(response.text.trim());
    if (Array.isArray(palette) && palette.every(item => typeof item === 'string' && item.startsWith('#'))) {
        return palette as string[];
    }
    throw new Error("AI returned an invalid palette format.");
  } catch (error) {
    console.error("Error generating color palette:", error);
    throw new Error("The AI failed to suggest a color palette. Please try again.");
  }
}


export async function generateInspirationPrompt(garment: string): Promise<string> {
  const prompt = `
    You are a creative director. Brainstorm a concise, visually interesting graphic design idea for a ${garment}.
    The idea should be suitable for a t-shirt graphic.
    The response should be short, punchy, and ready to be used as a generation prompt.
    For example, if the garment is a hoodie, you might suggest "minimalist line art of a mountain range" or "a retro-futuristic cassette tape".
    Respond with ONLY the idea text. Do not include conversational text like "Sure, here's an idea:".
  `;

  try {
    const response = await ai.models.generateContent({
      model: "gemini-2.5-flash",
      contents: prompt,
    });

    // Clean up quotes and trim whitespace
    const text = response.text.trim().replace(/^"|"$/g, '');
    if (!text) {
        throw new Error("The AI didn't return an idea. Try again.");
    }
    return text;
  } catch (error) {
    console.error("Error generating inspiration prompt:", error);
    throw new Error("Failed to get an idea from the AI. Please try again.");
  }
}

export async function modifyGarmentImage(baseImage: string, modification: ModificationRequest): Promise<string> {
   const fullPrompt = `
    You are a professional apparel design assistant. Your task is to perform a 'Direct-to-Garment' (DTG) modification on the provided base image, preserving photorealism.

    **Reference Image:** [Base Image Provided]

    **Modification Request:**
    - **Type:** ${modification.type}
    - **Content:** ${modification.content}
    - **Semantic Location:** ${modification.location || 'N/A'}
    - **Required Style:** ${modification.style}

    **Critical Instructions:**
    1.  **Mesh Analysis:** Analyze the topography of the garment in the Reference Image (folds, shadows, texture).
    2.  **Warping & Application:** Apply the requested content (${modification.content}) to the specified semantic location. The content must realistically follow the fabric's folds and shadows. It must appear printed or stitched onto the garment, not flatly overlaid.
    3.  **Style Matching:** Interpret the 'Required Style' to render the content correctly (e.g., if style is 'cracked, vintage varsity font', the text must look like that). For 'Structural' changes, apply the modification as described.
    4.  **Output:** Return ONLY the modified image, with the same dimensions and background as the original. Do not add text or watermarks.
   `;

   try {
    const imagePart = { inlineData: { mimeType: 'image/png', data: dataUrlToBase64(baseImage) } };
    const textPart = { text: fullPrompt };

    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash-image',
      contents: { parts: [imagePart, textPart] },
      config: {
        responseModalities: [Modality.IMAGE],
      },
    });

    const part = response.candidates?.[0]?.content?.parts?.[0];
    if (part?.inlineData) {
      return `data:image/png;base64,${part.inlineData.data}`;
    } else {
      console.error("Gemini API returned no image for modification:", JSON.stringify(response, null, 2));
      throw new Error("The AI failed to modify the garment.");
    }
   } catch (error: any) {
    console.error("Error calling Gemini API for garment modification:", error);
    if (error.toString().includes('RESOURCE_EXHAUSTED') || (error.message && error.message.includes('429'))) {
        throw new Error("Request limit reached. Please wait a moment and try again.");
    }
    throw new Error("Failed to modify garment. Please check the console for more details.");
   }
}


export async function renderRealisticComposite(baseImage: string, compositeGraphic: string): Promise<string> {
   const prompt = `
    Analyze the provided base apparel image and the separate composite graphic image.
    Your task is to create a new, hyper-realistic composite image by fusing the graphic onto the apparel.

    CRITICAL INSTRUCTIONS:
    1.  **Smart Displacement Mapping:** The graphic must be perfectly integrated into the apparel. It must follow and distort according to the fabric's natural folds, creases, wrinkles, and texture. It should not look like a flat sticker.
    2.  **Realistic Lighting:** Analyze the lighting and shadows of the base image (direction, softness, intensity) and accurately apply them to the graphic. The graphic must look like it exists in the same environment as the garment.
    3.  **Maintain Integrity:** Do not change the apparel, the graphic's core design, or the background. The final output must be a single, photorealistic image of the printed garment.
   `;

   try {
    const baseImagePart = { inlineData: { mimeType: 'image/png', data: dataUrlToBase64(baseImage) } };
    const graphicPart = { inlineData: { mimeType: 'image/png', data: dataUrlToBase64(compositeGraphic) } };
    const textPart = { text: prompt };

    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash-image',
      contents: { parts: [textPart, baseImagePart, graphicPart] },
      config: {
        responseModalities: [Modality.IMAGE],
      },
    });

    const part = response.candidates?.[0]?.content?.parts?.[0];
    if (part?.inlineData) {
      const base64ImageBytes: string = part.inlineData.data;
      return `data:image/png;base64,${base64ImageBytes}`;
    } else {
      throw new Error("The AI failed to render the realistic composite image.");
    }
   } catch (error: any) {
    console.error("Error calling Gemini API for realistic rendering:", error);
    if (error.toString().includes('RESOURCE_EXHAUSTED') || (error.message && error.message.includes('429'))) {
        throw new Error("Request limit reached. Please wait a moment and try again.");
    }
    throw new Error("Failed to render realistic mockup. Please check the console for more details.");
   }
}

export async function propagateDesignToView(
  renderedSourceImage: string,
  cleanTargetImage: string,
  sourceView: string,
  targetView: string
): Promise<string> {
  const prompt = `
    You are a 360Â° product visualizer. Your task is to propagate a design from one view of a garment to another.

    **Image 1 (Reference):** Shows the '${sourceView}' view of a garment with a design applied.
    **Image 2 (Target):** Shows the clean '${targetView}' view of the SAME garment.

    **Instructions:**
    1.  **Analyze Design:** Examine Image 1 to identify all non-original design elements (graphics, text, etc.).
    2.  **Logical Inference:** Determine if and how these design elements would be visible or continue onto Image 2. For example, a sleeve graphic might wrap around and be partially visible from the back. A chest graphic would not be visible from the back.
    3.  **Apply Changes:** Modify Image 2 ONLY to include the relevant, visible parts of the design.
    4.  **Maintain Realism:** The applied changes must perfectly match the style, lighting, and texture of both source images.
    5.  **Output:** Return the modified Image 2. If no design from Image 1 would logically be visible on Image 2, return Image 2 unchanged.
  `;

  try {
    const sourceImagePart = { inlineData: { mimeType: 'image/png', data: dataUrlToBase64(renderedSourceImage) } };
    const targetImagePart = { inlineData: { mimeType: 'image/png', data: dataUrlToBase64(cleanTargetImage) } };
    const textPart = { text: prompt };

    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash-image',
      contents: { parts: [textPart, sourceImagePart, targetImagePart] },
      config: {
        responseModalities: [Modality.IMAGE],
      },
    });

    const part = response.candidates?.[0]?.content?.parts?.[0];
    if (part?.inlineData) {
      return `data:image/png;base64,${part.inlineData.data}`;
    } else {
      console.error(`Gemini API returned no image for design propagation to ${targetView}:`, JSON.stringify(response, null, 2));
      throw new Error(`The AI failed to propagate the design to the ${targetView} view.`);
    }
  } catch (error: any) {
    console.error(`Error propagating design to ${targetView}:`, error);
    if (error.toString().includes('RESOURCE_EXHAUSTED') || (error.message && error.message.includes('429'))) {
        throw new Error("Request limit reached while propagating design. Please wait and try again.");
    }
    throw new Error(`Failed to propagate design to the ${targetView} view. Please try again.`);
  }
}
